So now that we've talked about what BigQuery is, let's move on and talk about, how do you write queries? And how do you write functions in BigQuery? To run a query, you basically use a web console as I showed earlier, okay. So this is what the web console looks like, you know it changes over time so don't worry about if your web console doesn't look exactly the same. It's the basic concepts that matter. So that red button there, you click on it if you want to run the query. You write the query in that text box where it says 'New Query', you write the query and you'll see that I have the query editor. So, what you can do, the rest of the menu is about how to save and share things. So you have ways to save the query, save the view, okay. You also have options like I showed you one option where I hit the show options and I turned on, turned off the legacy sequel which is the original Google sequel that currently is a default and bigquery for all, all of this course I'll use standard sequel. So I will basically just go ahead and turn off that toggle so that we're using standard sequel and not Google sequel. The explanation, we'll look at it later as a way to analyze query performance. And what you see here are the results. You can basically take these results, the results of a query and you can download it as a CSV file, download as a JSON, save it as another table, right, so this materializes it. The difference between a view and a table is that, a new table is materialized, it is no longer live. A view is not materialized and therefore it is live. That little green arrow there is actually pretty cool, once you write a query you can basically click on a green arrow, it will validate it, it will tell you how much data is going to get processed. So you can use this validate button to get an idea of cost if you are on a per use billing. If on the other hand, you're on a flat rate pricing then you don't really care but it's still, maybe you still care. Maybe you want to know how much data gets processed because that's the amount of resources that you're using and that's the amount of resources that somebody else on that same flat rate plan doesn't have available to them at that exact time your query is running. And then finally, also you can export into Google sheets as well not just as CSV or JSON but you can export to Google sheets. In fact one of the cool things is, you can define a Google sheet as your external table. And that is the reason I've said it's very cool is that, you can write a query and this query can be extremely complex that runs in a very large petabyte scale dataset and then your Google sheet can be this really tiny table, human editable table, that maybe has like 10 rows in it that says this is the customer IDs I'm interested, these are the products I'm interested in, these are the dates that I'm interested in. And then you can do a join of the Google sheet with this massive dataset and that's what your query could be. Your query could be joining a very large data set with a human editable Google sheet and then you can take the result and you can export it to Google sheet as well. The query syntax itself is sequel 2011 plus a few extensions of the look alike. So here for example is how that looks like, select airline, right, sum of something, count of something, from a table. The table itself, the format is <project>.<dataset>.<table>. The project here is bigquery-samples. That dataset is airline_ontime_data, and the table is flights. If you leave out the project, by default, it will be the current project. Whatever project is on the console. I mean one of the things that we've realized is that even though we're going to be showing it to you on the bigquery console, very often, you would be calling the bigquery query from within your Java or Python or some other program. Great. What the bigquery console does is just essentially arrest API. And there are a variety of client libraries that use that exact same rest API. So you can use it from Python, you can get back a Pandas data frame, the big query results that comes back as a Pandas data frame. And then you can basically use it like Pandas, right. But whichever project is a current project, that's what will be if you leave out the project, but you will always need data set dot table. And then you're selecting from a table where arrival airport is OKC, so arrival airport, that is a column, departure airport is another column, right to those... that's a WHERE clause and basically see a Boolean operation there, and I'm grouping all of this by airline, so I'm selecting the airline and for every airline, right, if you look at the select statement. For every airline, right, I'm also finding because of grouping by it, I'm finding that number delayed. And how do I get the number delayed? I checked the arrival delay column. If it is greater than zero, I say one. If it's not greater than zero, I emit zero. So if the arrival date is, arrival delay is greater than zero. That's the total number of flights that arrived late. So the sum of all of that is a number delayed. And then I do a count of arrival delays. I count the number of times there is an arrival delay in the datasets. So arrival delays not equal to null, essentially is what that is. So I'm just counting all of those. And that's the total number of flights. And by the way, in this particular dataset arrival delay will be null if this flight was canceled. Right. So we're not counting those. So we're basically finding that number delayed, the total number of flights and that's basically what the query result is. So I have airline, I have the number delayed and I have the total number of flights when grouped by airline. 

So, notice that in my query here I'm doing an aggregate function, sum and counter aggregate functions. So I'm basically going through and for every, because here now if you look at the group by, I'm grouping by airline, departure_airport. So there are two things I'm grouping by. So for every airline and departure airport pair, I'm finding the number of delayed flights and the total number of flights. The WHERE clause is simply arrival_airport is OKC. So now I'm basically saying for all flights flying into Oklahoma City, find me for every airline, every departure airport, the total number of delayed and the total number of flights. So for example, let me pick something that I know. The 5th one, the airline is northwest, the departure airport is Minneapolis-St. Paul. There are 17 delayed flights of a total of 35 flights. So what GROUP BY does is that it basically returns the fields of sub server grouping by airline and departure airport and then for each one of those, it returns a bag and then you aggregate that bag to basically get something out of it. So here I'm using two aggregates, sum and count. So those are two functions that occur on the bag. But my select statement can include the two grouped fields airline and departure airport because I'm grouping by them. So there's, those are, both for every row if you will of the result set, there will be one airline and one departure airport, but there will be many flights. So I basically have to take all of those flights, and have to aggregate them somehow. So here what I'm doing is that I'm finding the total number of flights for which arrival delay is not null, that is all total flights and I'm basically finding the number of ones for it's arrival delays greater than zero. That's the number delayed.

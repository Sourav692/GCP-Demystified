So far, we've looked at only JOIN on equality conditions. So for example in the Washington case, we looked at a JOIN, an INNER JOIN, where the station_id in this table is equal to the station_id in that other table. But JOINs are not limited to just equality conditions. You can actually JOIN on two tables using any Boolean condition. Obviously, less than, greater than, etcetera, but also functions that return a Boolean. For example, the starts with method, returns a Boolean. Does the word start with this prefix? Or does it not start with the prefix? So, what does this query do, we have a table called USA Names between 1910 and 2013. So basically, all of the names given to babies in the United States. So every name, we're counting the number of times that a baby has been given that name, so these are now the names and the sum of numbers, these are occurences and I'm ordering by occurences, descending, limit 100, so now we have found the 100 most common names given to babies. That's my top names and from the top names, I'm selecting the name and I'm selecting word count. What is word count?

The word count is essentially

obtained by joining Shakespeare, the big query public data sample is Shakespeare, we are joining it on the word in this corpus, whether it starts with a name or not, grouping it by name, ordering it by frequency. So this table contains a word and contains a word count and we're basically finding all of the words in Shakespeare that start with a specific name and we're summing them all up and grouping it by name. So we are finding the names that occur most commonly in Shakespeare, order by frequency and showing you the top down.

So it turns out, no surprise, John's one of the most frequent names. One of the most common names that also shows up in Shakespeare quite a bit. Henry, Edward, Richard, Helen interestingly enough, Mark, Jack, etc.

Over the course of these example queries, we've looked at a variety of standard SQL functions. There are a variety of standard SQL functions, aggregate functions like sum, count, max, etc. String functions, analytic functions, datetime functions, array functions, let's look at a few of them. So for example, a string function, reg expression, REGEXP_CONTAINS is a string function. And what this is doing is, again, the Shakespeare corpus contains a word and a word count. So here is a word, and we're basically saying does it contain two letters followed by an apostrophe, followed by two letters. Well, here's some words that match. There's ne'er, we'll, and so we are basically finding all of those words. And we're basically showing the count of those words, is the word count, grouping the word and showing you the counts. So the number of times that the word occurs in the works of Shakespeare. So these are the three most common words that meet that specific regular expansion button. What we're showing you here of course, is that you can do a regular expression match within the query You can also do analytical window functions, so sums, averages, min, max, count, etc, but you can also do navigation stuff, which is kind of cool. So if you are on a particular row, you can say show me the row that is n rows ahead of this row, or n rows behind this row, so lead and lag. You can also do things like medium, things like the 10th percentile, 20th percentile, by using and NTH value. Lead, lag, Nth value, all of these make sense once you have an ordered dataset. But if you just do a select on BigQuery, the order in which the things come back is pretty arbitrary. But once you've done in order by, you've now done, you now have a defined order, lead, lag, Nth value, etc., they start to make sense.

So again, these are all within Windows, you're basically applying them on some Group of records, and we will look at examples of those. You also have ways to rank, percent rank, row number within a result set, cumulative distribution, etc. So let's look at a couple of examples.

So, the thing to realize is that all the analytical functions, they compute aggregate values over groups of rows, and or windows of rows. So here's an example. Analytical functions compute aggregate values over groups of rows or windows of rows, so whenever you do an analytical function that uses a window that's things like rank for example, it basically needs to be window over what? So you have an over clause. So here's an example of a window function. So here, what I'm doing is I'm taking, again, the word, the Shakespeare canon; and it happens to have a column called corpus, which is the name of the play. So I'm basically saying select the corpus, select the word, and select the word count, and rank within the corpus. So we are partitioning it by corpus, ordering by word count descending, and we are finding the rank within that corpus. And this probably makes more sense if you look at the result. We have a corpus Henry V, the word is Westmoreland, it occurs 15 times, so it's rank is one. Henry VIII, the word is Chamberlain, it's the most common word â€“ it occurs 53 times. Henry VI, Northumberland occurs 21 times, it's rank is one, but in Henry VI again, Plantagenet occurs 14 times, so its rank is two, so this is the rank two within this corpus. Similarly, Northumberland in Henry IV is the second most common word. And again, in Henry IV, Westmoreland occurs slightly more often.

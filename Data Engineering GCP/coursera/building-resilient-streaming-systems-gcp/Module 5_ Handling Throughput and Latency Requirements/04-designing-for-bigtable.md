## Designing for Bigtable
So how do we design for Bigtable with this understanding that Bigtable separates out computing and storage. And by the way why does it separate out computing and storage? So that it can do auto scaling. Right, now if we get a new cluster that comes up, what does that new cluster have to do? It only needs to point us to the data, it doesn't need to have the data. It only needs to point us to the data. So in order to do our design in Bigtable, the first thing is that tables in Bigtable have only one index which is the row key. So you have rows of data. Every row has a key. So essentially all you are storing in big table is a key value pair. So you have a key and you have some values. Those values can have columns and those columns can be what we call column families but only one of those columns is the key. So in this case we have the row key and all of the rows are stored in ascending order of this row key. None of the other columns can be indexed. The only thing that's indexable is a row key. So what we do when we design Bigtable is that we take information that belongs together and group them together into what are called column families. So in this case in this table, I have two column families. I have one column family called user information, another column family called Profile_statistics. So birthday, age and gender are all information about the user but the number of messages that the user has sent, that is profile_statistics. So in some ways you can think of the user information as this very slow changing information and the profile_statistics as being this fast changing information. And so that's another thing to think about when we think in terms of what kinds of columns go into a column family. So that brings up this point, the number of followers that a user has, where should it be? Should it be in the user information column family or should it be the profile_statistics column family? Once you say that the user information tends to be static information, it doesn't tend to come in streaming all the time but followers and messageCounts keep changing. Whenever the user basically hits a like on somebody's message or somebody's profile they become a follower of that person. So the number of followers increases etc. So you can think of the followers and the number of messageCounts as being this data that's constantly updated, so it might be good to move those followers into the profile_statistics. So that's the way you think about column families. Related columns that tend to be updated together. When we design Bigtable, you essentially choose among one of two types of designs. These are the two most common types of designs in Bigtable. One type of design is where you have a wide table. A wide table is a table where you have a number of columns and each column value exist for every row. Notice that Andrew, this row has a value for followers, a value for birth date, a value for age, a value for gender, a value for messageCount. So does Brianna, so does Caitlyn. Every one of these rows has an actual value for each of these columns, and if that's the case then you can think of for every row, you basically have all of these values. And we think of that as like a wide table. On the other hand you may have sparse tables, tables in which many of the columns will not have any data in them. Think for example about users providing ratings on products. How many products does a user rate? Maybe three, maybe four. So if we were to make a wide table, we'd basically have a number of all the users on one axis, so a row for every user, a column for every product, a column for every movie for example, and only a few of those columns will have data in them. That's very wasteful. Instead what we would do in Bigtable, is that we do that as a narrow table. So a narrow table is great for sparse data. So in this case what we would do is that for every user we'd only store the names of the movie and the rating of the movie that they have actually rated. So here for example, whereas we're looking at a narrow table that consists of which user follows which other user. Again you may have millions of users and any particular user we don't to store a million columns for this other pair of users that this guy could follow. Instead what we will end up doing, is that we will store for every username the actual person that they've followed and you will have multiple rows. Right? That consists of this pair but of course each row has to have a unique key. So what we'll do is that we'll make the key itself consist of this pair of the follower and the person that they follow, and that becomes a unique key, and then you can actually store in plain text, in this case the name of the follower or the name of the followers and other information about when did this follow happen etc. So you will have only those keys that actually make sense and the rest of the column would not actually have an entry in the table. So that's another way of doing your design. So think in terms of is your data dense or is your data sparse and depending on whether it's dense or sparse choose between one of these two types of designs.
## Rows are sorted lexicographically by row key, from lowest to highest byte string
Now, the thing to remember is that in BigQuery rows are sorted.

So they're stored sorted. Every tablet is going to consist of contiguous rows.

And rows are going to be sorted starting from the lowest to the highest, so that they're going to be sorted in ascending order.

So if you have data corresponding to all of these things, they're going to be encoded actually in this particular order, right? They're going to be Andrew, Bob, Jesse, Sandy and Zachary. They're going to be in alphabetical order. So all of your rows, your row keys, are going to be stored in sorted order. So, given these facts, let's talk about how we optimize the design of the Bigtable.

So the basic principle is that if you can query the data, queries that use the row key, or use a row prefix, or use a row range, are the most efficient. This makes sense because the only thing that we're ever indexing is the row key. Any query that uses a row key is going to be more efficient because any other query will essentially end up reading the entire table. And we don't want to read the entire table. So, we want to use the row key as much as possible, that is the only thing that's indexed. So any query that uses a row key, but not just the row key. It turns out that Bigtable will let you use a prefix from the row key. So that it does, you don't have to use the entire key. You can say get me all the rows whose keys starts with these three letters. And that is also efficient because the rows are stored in ascending order. So it can go ahead and find all the keys that start with something very quickly.

So, when you design your Bigtable, the question that you want to ask, the first question, is what is the most common query that we need to support?

That most common query that you need to support essentially helps you figure out what your row key needs to be. Your row key needs to reflect this most common query. So, for example, if we're always going to be searching for

tell me the speed of I-35, that's my highway, at mile marker something, at 347, then you want to make that query parameter, the highway and the mile marker, you want to make it the beginning of the row key. You can have other things in the row key, but you want to say, you want to have someone be able to say give me all the rows that begin with I35 and 347. Or maybe all the queries are going to be about what's the speed on I35. And if they are just going to ask you the speed of a highway, you want the highway to be the first part of the road.
## Store related entities in adjacent rows
So the reason that this works is because your basically, big table's storing keys in sorted order. So which means that, when you're thinking about how you make your keys, you want to basically make it such that related entities are stored adjacently. So you want it such that when the user does a query,

you want to provide back to them rows that are contiguous. You want to basically make it such that users are very likely to pull records that are contiguous. Because that's going to make your read efficient. It's so much faster, if we can give you back results from the same tablet. If the results are going to have to get pulled in from multiple tablets, that's going to be a lot slower than if the results come from the same tablet.

And the only way the results are going to come from the same tablet is if you're asking for records. Whose keys are contiguous, whose keys are one after the other. So we want to make it basically, such that we design our keys so that the most common queries return adjacent rows.

The second thing that you might want to do, is to ask a question. Will a very common use case b, give me the latest few records. The last few records. And if you're going to be getting the last few records all the time

then think about it, what's the last few records? The last few is essentially about time stamp. So you want to add the time stamp to the key.

But you don't want to add the time stamp as is to the key, why not?

Suppose you add a time stamp to the key. Think about your time stamp, let's say your time stamp is the year, month, and day.

And if you add that time stamp to the key,

what is going to be the first part of the key?

So what is going to be the first part of the time stamp?

The first part of the time stamp is going to be the year. And earlier years are going to be coming after the later years. So if you start your data collection in 2008, the 2008 records are going to be at the front of your table. And your latest data, 2017, 2018, all that data's going to be at the bottom.

So if what we want is to retrieve the latest few records we shouldn't store the data in ascending order of time stamp. We need to store our data in descending order of time stamp.

But Bigtable doesn't do that, Bigtable only stores things in ascending order of the row key. So what we're going to do is that in a row key we're going to put in the reverse timestamp so that the latest records are first. So that's what we're going to be doing. So our row key is going to be the highway and the milemarker that's because that's the most common query. People will want to know where I am or where I'm headed. What is the speed going to be, right? And they know where they're headed because of GPS software is going to say, this person is traveling on I35 and they're currently on mile number 345. They're moving north. And therefore, I'm interested in mile markers 346 and 347 and 348. So that's a very common query. And because that's a very common query, we put that as a query parameter. We make that the row key. But we are also not interested in the speed yesterday or the day before or three days ago. We're interested in the speed now, the latest few records of speed. And because of that, the third part is going to be the reverse time stamp. So that we get the latest few records from this highway and mile marker before anything else.

## Distribute your writes and reads across rows
The second thing that you want to think about is how you do your reads and how you do your writes. We already talked a little bit about reads.

The way we want to do our reads is that we want contiguous rows. Rows that are next to each other to get returned in one go. But at the same time, you want to think about Bigtable assets operating for multiple users over the entire application. You want your reads and writes to be distributed. In other words, you don't want all the activity to happen on just one tablet. You want the activity to happen on multiple tablets, so that multiple nodes are basically carrying out the job. So you want your reads and writes to be evenly distributed, so that the work load on all of these nodes are balanced. If your reads and writes are concentrated on one set of keys, then it's going to be one tablet and one node that's going to be doing the brunt of the work and that's not a very scalable design. So, what we need is distribution of reads and writes.

So, how do we distribute our reads and writes? We want to basically avoid hotspotting. We don't want a single node to take a bunch of the activity. So in order to do that, we want to think about what kind of row keys we shouldn't be doing.

We should not, for example, have a row key that's a domain and a reason we don't want our row key to start with the domain is you imagine that you're looking at domains that the people are going to be coming in from. It is going to be usually the case that certain domains are extremely active than other domains.

So let's say, for example, you have hundreds of customers and you're basically storing the domain of those customers. It's possible that two or three of your customers are actually responsible for 30, 40% of your business and the tablets corresponding to those customers are going to basically cause hotspotting. So, we don't want to do that. Domains are okay to use, but you don't want your row key to start with the domain. So the row key can be part of the domain, but you don't want the row key to start with the domain. Because that's going to reflect which node is going to be taking the brunt of the processing.

You don't want user IDs to be your row key,

if your user IDs are sequentially assigned. It's okay if your user IDs are randomly assigned, if you're just using a hash code. So, something very arbitrary and something very random. That's fine to have a user ID as your row key. But if your user IDs are sequential, that could be a problem. Because in many applications, newer users are going to be more active than users that were created six, seven years ago. And what this means is that all the nodes, remember that the rows are organized in ascending order. So you will have some tablets consisting of all old users and some tablets consisting of all new users, and the ones that correspond new users will tend to be more active. That's a problem. That's hotspotting. You want the reads and writes to be distributed. You want all of the tablets to be actually doing work at all times, all of the nodes to actually be doing work at all times.

Similarly, you don't want to have a static identifier as a key, especially if you have a static identifier that's going to keep getting used. So for example, if you have a rogue key that's mem usage or CPU usage or disk usage and you keep updating it over and over again, it could be the case that those tablets, those nodes that are basically doing this processing for this constantly updated data. They're going to basically get overworked.
## Distribute the writing load between tablets while allowing common queries to return consecutive rows
So what should you do? What you should do is that you need to distribute this writing load. So you want to basically distribute the writing load, so as the data are coming in, you want to be writing to all of the tablets. You don't want to be writing to just one tablet. 

But at the same time, you want to design your row key such that when people do queries, they basically get back adjacent rows, consecutive rows. And we need to balance this.

So this key that we did earlier, highway-MILEMARKER and reverse time stamp, actually does this quite well, right? So think about it, so what kind of query do people do?

A single person would say, I'm travelling on I35. Give me the mile marker 347. But is every user on your system going to be travelling on I35 and going to be on mile marker 347? No, right, you will have users all over the city. All of them would be on different highways. They'll be at different mile markers. So in some sense, the reads are going to be distributed. The writes are also going to be distributed, because you have sensors on all the highways, all the mile markers. They're all going to be sending you the data. So all the nodes that are going to get approximately equal amount of work. And they're basically going to be reading and writing, so that's great. So we have distributed writes, we have distributed reads. But at the same time, for any particular user, when they're asking you for their data, you get to give them consecutive rules. And that's basically the idea.

Now, this works, let's take some options, some alternatives to basically see things that don't work. Okay, so let's say for example we designed it to be time stamp highway then mile marker.

What's the problem here?

Now this is a problem because this is very similar to the user ID idea, right? You will have data for a particular timestamp being written right now. So all the sensors, all the data that's coming in is going to go into the same tablet. Because all the rows start with a time stamp. So this works whether it's reverse time stamp or regular time stamp. You're writing to the same tablet because all of these sensors are sending data at the same time.

And because they're all sending data at the same time, if your row key starts with the time, your host. You don't want your row key to start with the time. Because then it's the same tablet that's going to get over worked. Let's take the second one, suppose you do a mile marker first and then the highway and then you have the reverse timestamp. Now what's the problem? The problem happens, this seems to be fine, but think about the typical use case. The typical use case is going to be a graph plotting software that's basically trying to choose between some route, one route or the other route. And typically people ask you for what is the average speed on a particular highway, right? And you want to basically say on this highway, between miles 340 and 350, because those are the two intersections, tell me the speed.

That kind of query becomes extremely hard if you start with a mile marker. Because now if you're asking for all of the data from miles 340 to 350, you're not reading contiguous rows anymore. You're reading rows from maybe ten different tablets. So the problem with this, starting with the mile marker, is that your queries are not going to be returning consecutive rows. Your query, for give me the speed between mile marker 340 and mile marker 350 on highway I35.

That's not going to be consecutive rows that's going to read from multiple tablets, and that's a problem. So you want, again, so when you think about your design you want to think in terms of how do I organize my row key so that I return adjacent rows as much as possible. So that I have distributed writing as much as possible and distributed reads as much as possible.
